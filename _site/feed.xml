<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FoolishTalk</title>
    <description></description>
    <link>http://www.foolishtalk.org/</link>
    <atom:link href="http://www.foolishtalk.org/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 26 Jun 2018 15:22:59 +0800</pubDate>
    <lastBuildDate>Tue, 26 Jun 2018 15:22:59 +0800</lastBuildDate>
    <generator>Jekyll v3.7.0</generator>
    
      <item>
        <title>RxSwift从入门到放弃——Rxswift与MVVM的邂逅</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;这篇出来的比较晚，最近事情也比较多，一直没时间写，这篇是作为开篇到RxSwift源码分析的过渡。&lt;del&gt;当然也是因为前几天我在公司内部分享ppt的内容也是这个&lt;/del&gt;就把这篇当作番外篇看看好了[doge]&lt;/p&gt;

&lt;h1 id=&quot;这篇聊点什么&quot;&gt;这篇聊点什么？&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;MVVM和RxSwift之间的关系&lt;/li&gt;
  &lt;li&gt;MVVM是什么？&lt;/li&gt;
  &lt;li&gt;RxSwift能解决MVVM什么问题？&lt;/li&gt;
  &lt;li&gt;RxSwift的看法&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;mvvm和rxswift之间的关系&quot;&gt;MVVM和RxSwift之间的关系&lt;/h2&gt;
&lt;p&gt;我们在讲到RxSwift的时候，基本肯定会聊到MVVM，如果不太了解MVVM，可以先看后面&lt;code class=&quot;highlighter-rouge&quot;&gt;MVVM是什么？&lt;/code&gt;。&lt;br /&gt;
首先MVVM需要有ViewModel，iOS原生并没有提供很好的数据绑定方式，使用RxSwift、RxCocoa提供了已经封装好了数据与UI绑定的方法，使得数据绑定简单了起来。&lt;br /&gt;
使用了RxSwift也并不是必须使用MVVM，使用MVVM架构，也并不是必须要使用RxSwift才能实现。&lt;/p&gt;

&lt;h2 id=&quot;mvvm是什么&quot;&gt;MVVM是什么？&lt;/h2&gt;
&lt;p&gt;对于这个问题，我强烈推荐先去看看casa的&lt;a href=&quot;http://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html&quot;&gt;iOS应用架构谈 view层的组织和调用方案&lt;/a&gt;，在这方面业内近年来已经都很少聊这方面的话题，我会讲讲我的看法，如果有什么错误，希望读者能在评论区指出。&lt;/p&gt;

&lt;p&gt;要聊MVVM是什么，就得先聊聊MVC。&lt;br /&gt;
&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/mvc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;一张来自斯坦福大学iOS公开课很经典的图，每次第一节课，都会放上这张图，这个图已经很好说明了MVC的关系。&lt;/p&gt;

&lt;p&gt;Model:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;给Controller监听，提供数据&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;View:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;生成视图元素&lt;/li&gt;
  &lt;li&gt;处理内部和业务无关的逻辑、交互，以及动画&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Controller:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;把View加载到Controller上&lt;/li&gt;
  &lt;li&gt;负责实现View的delegate、dataSource，拿到Model，做对应业务逻辑的处理&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这种分工形成MVC的格局，然而在实际iOS开发中，往往会形成像下面的交互：&lt;br /&gt;
&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/mvcnotify.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
在一些业务、界面复杂，多逻辑交互的时候，View的地位很尴尬，他不能直接和Model通讯，只能依赖Controller，这样就导致大量的delegate、action都由Controller去实现，业务的代码放View里又不方便监听变化，这时候能怎么办？只能往Controller里面放，因为这样，Controller变得异常的庞大同时难以复用，也是因为这个原因，就有人提出MVVM，来帮Controller瘦身。&lt;br /&gt;
问题来了，MVVM是怎么帮Controller瘦身的呢？&lt;br /&gt;
&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/MCVMVMV.gif&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
通过这张图就可以看出，MVVM其实就是在MVC的基础上，抽离了Controller的业务逻辑，移到了ViewModel,他们之间其实是这样的关系：&lt;br /&gt;
&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/mvvm_logic.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;View层和之前做的事情一样，Controller订阅viewModel的事件变化，将View绑定到ViewModel上，要注意在Rx的思想里，ViewModel并不是直接拿到View，而是View的观察者属性或者可观察的序列。另外Controller也会基于ViewModel事件的响应做对应的交互逻辑。&lt;/p&gt;

&lt;h2 id=&quot;rxswift能解决mvvm什么问题&quot;&gt;RxSwift能解决MVVM什么问题？&lt;/h2&gt;
&lt;p&gt;RxSwift为我们平时使用的UI控件提供了响应式函数，使用自带的响应式函数就能非常方便的进行数据绑定。 
例如我们实现了一个选择体重尺子功能的View：&lt;br /&gt;
以前的做法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    func scrollRuleValue(collectionView: UICollectionView, value: CGFloat) {
        if collectionView == containerView.weightRuleView.collectionView {
            containerView.weightLabel.text = &quot;\(value)kg&quot;
        }
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;利用RxSwift的特性：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;        containerView.weightRuleView.observerValue.map { (value) -&amp;gt; String in
            return &quot;\(value)kg&quot;
            }.bind(to: containerView.weightLabel.rx.text).disposed(by: disposeBag)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这行代码的意思：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;监听ruleView的observerValue序列发送;&lt;/li&gt;
  &lt;li&gt;将发送变化的体重值从CGFloat类型格式化成我们需要的字符串;&lt;/li&gt;
  &lt;li&gt;将尺子滑动变化的序列绑定到需要显示体重的label上;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这是一个在Cocoa编程里最常见的委托代理模式，将视图变化交给Controller去处理，再去更新视图。而RxSwift只需要让ruleView创建一个发送数据的序列，再由Controller与需要更新的视图进行绑定，这样就能节省大量在写代理时候的代码。&lt;/p&gt;

&lt;p&gt;利用已经提供好的属性，既避免了ViewModel直接拿到View，可以随意的更改View属性，同时还节省了大量代码。另外一方面，由于业务逻辑已经都移到了ViewModel，对于业务的单元测试也变得极其简单，对于RxSwift的单元测试，可以了解一下&lt;code class=&quot;highlighter-rouge&quot;&gt;RxTest&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;RxBlocking&lt;/code&gt;，本文就不展开说了。&lt;/p&gt;

&lt;h2 id=&quot;rxswift的看法&quot;&gt;RxSwift的看法&lt;/h2&gt;
&lt;p&gt;个人觉得，RxSwift给我们带来最大影响的Reactive思想，OOP告诉我们，在编写应用程序的时候，要考虑的是对象有什么，对象做什么，对象与对象之间的联系，而Reactive思想将对象所做的都看成是数据流，我们关注的是事件本身的影响，学习一个新的编程范式，还是非常有意思的。&lt;br /&gt;
当然RxSwift也会有不好的地方，RxSwift对工程的侵入性非常的大，引入RxSwift会让整个程序代码都焕然一新，和过去Cocoa开发方式截然不同，这样也导致Rx新手难以理解其中代码，可以说是极度不友好了。&lt;br /&gt;
不过说了这么说，Reactive其中的响应式思想还是很值得我们去学习的，对于拿来开发项目，小项目可以拿来写着玩耍，体会新的编程范式，大型项目，就得做好踩坑的心理准备了。&lt;/p&gt;
</description>
        <pubDate>Sat, 26 May 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/05/26/RxSwift%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-Rxswift%E4%B8%8EMVVM%E7%9A%84%E9%82%82%E9%80%85/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/05/26/RxSwift%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-Rxswift%E4%B8%8EMVVM%E7%9A%84%E9%82%82%E9%80%85/</guid>
        
        <category>RxSwift</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>RxSwift从入门到放弃——开篇</title>
        <description>&lt;h1 id=&quot;前言&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;最近正好在刚好被安排到用RxSwift开发一个小项目，借着这个机会学习了一下。在这之前也有断断续续用了几次，最后总会因为各种各样的Xcode问题弃坑，感觉能坚持下来真的是真爱啊。。主要学起来就是两个问题：&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Xcode的自动补全十分不友好&lt;/li&gt;
  &lt;li&gt;RxSwift学习曲线陡峭&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;自动补全的问题对刚入门的时候来说，真的影响很大，一开始对RxSwift的不了解，看了下网上的资料，准备大干一场的时候，写着写着，突然没补全，然后怀疑自己是不是哪里写错了，把网上的代码复制过来，又可以了，体验极其的差…&lt;/p&gt;

&lt;p&gt;在学习RxSwift的时候，或者本来就有看过相关的资料，肯定会对下面这张图的名词有所听闻。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/rxswift-know.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;不了解的同学看完应该是这样的表情的：&lt;br /&gt;
&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/black_question.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;看不懂没关系，看完这个系列的文章之后，就会懂了。&lt;/p&gt;

&lt;h1 id=&quot;疑问&quot;&gt;疑问&lt;/h1&gt;
&lt;p&gt;在学RxSwift之前，先提个问题，为什么要学习RxSwift？&lt;br /&gt;
这段是从RxSwift文档翻译过来的回答&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;可组合，因为Rx就是这个意思&lt;/li&gt;
  &lt;li&gt;可复用，因为它是可组合的&lt;/li&gt;
  &lt;li&gt;清晰，因为声明都是不可变的，改变的只有数据&lt;/li&gt;
  &lt;li&gt;容易理解和简洁&lt;/li&gt;
  &lt;li&gt;稳定&lt;/li&gt;
  &lt;li&gt;没有状态，因为RxSwift将应用程序建模为单向数据流&lt;/li&gt;
  &lt;li&gt;不会有内存管理问题，因为内存管理变得简单&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;总结：使用RxSwift可以简化代码，用更少而且清晰的代码，更专注于关心事件变化的本身&lt;/p&gt;

&lt;p&gt;说了这么多，RxSwift其实到底干了什么？
RxSwift将监听变化的&lt;code class=&quot;highlighter-rouge&quot;&gt;事件&lt;/code&gt;封装成了可观察的&lt;code class=&quot;highlighter-rouge&quot;&gt;序列&lt;/code&gt;，因此在编程的时候，通过框架已经帮我们创建好的序列或者自己创建的序列，实现对序列的监听，只关心序列的变化。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;注&lt;br /&gt;
可观察的事件：例如scrollView的contentOffset变化，textField每次输入时候变化的text等&lt;br /&gt;
序列：一个可被观察的对象，后面会详细讲到。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;正文&quot;&gt;正文&lt;/h1&gt;

&lt;p&gt;讲了这么多，talk is cheap,show me the code.&lt;/p&gt;

&lt;p&gt;监听collectionView的contentOffset，没有引入RxSwift的时候，我们需要实现以下方法：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt; func scrollViewDidScroll(_ scrollView: UIScrollView) {
     //...
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;引入RxSwift之后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let disposeBag = DisposeBag()


       collectionView.rx
                    .contentOffset
                    .subscribe(onNext: { (point) in
            //do something
        }).disposed(by: disposeBag)
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
  &lt;p&gt;注&lt;br /&gt;
disposeBag负责管理生命周期，相当于将当前的监听交给了disposeBag，大部分情况下disposeBag由Controller持有，并随控制器生命周期结束而结束&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;KVO:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;view.rx.observe(CGRect.self, &quot;frame&quot;)
    .subscribe(onNext: { frame in
        print(&quot;Got new frame \(frame)&quot;)
    })
    .disposed(by: disposeBag)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Target-Action:&lt;br /&gt;
传统的实现方法:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    lazy var button: UIButton = {
        var button = UIButton()
        button.addTarget(self, action: #selector(click), for: .touchUpInside)
        return button
    }()
    
    @objc func click() {
        // do something
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;button.rx
    .controlEvent(.touchUpInside)
    .subscribe(onNext: {  () in
    //..touchUp

        }).disposed(by: disposeBag)

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的都是简单的例子应用，下面直接用登录功能举例示例代码，&lt;a href=&quot;https://github.com/Fidetro/rx-sample-code&quot;&gt;代码&lt;/a&gt;已经传到GitHub上了。&lt;br /&gt;
要实现的功能：点击按钮的时候，判断用户名和密码是否合法，然后请求，拿到结果。&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;创建一个ViewModel
    &lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;class LoginViewModel: NSObject {
 //由Controller负责订阅loginResult，得到登录结果
 let loginResult: Observable&amp;lt;Bool&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;初始化loginResult
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; init(input: (username: Observable&amp;lt;String&amp;gt;, password: Observable&amp;lt;String&amp;gt;, touchUp: ControlEvent&amp;lt;()&amp;gt;)) {
     //将username和passowrd变形为Observable&amp;lt;(String,String)&amp;gt;
     let usernameAndPassword = Observable.combineLatest(input.username, input.password) {
         ($0, $1)
     }
     //初始化loginResult对象
     loginResult = input.touchUp.withLatestFrom(usernameAndPassword).flatMap { (username,password) -&amp;gt; Observable&amp;lt;Bool&amp;gt; in  

         //简单的对用户名和密码做校验
         guard  username.count &amp;gt; 6 else{
             return Observable.just(false)
         }

         guard  password.count &amp;gt; 6 else{
             return Observable.just(false)
         }

         return Observable.create { (observer) -&amp;gt; Disposable in
             //延时1s模拟异步请求登录成功
             DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + 1, execute: {
                 observer.onNext(true)
             })
             return Disposables.create {}
         }
     }        
 }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;在Controller监听点击后登录的结果：
    &lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt; @IBOutlet weak var loginButton: UIButton!
 @IBOutlet weak var usernameTextField: UITextField!
 @IBOutlet weak var passwordTextField: UITextField!
 let disposeBag = DisposeBag()
    
    
 override func viewDidLoad() {
     super.viewDidLoad()
     let viewModel = LoginViewModel.init(input: (username: usernameTextField.rx.text.orEmpty.asObservable(),
                                                 password: passwordTextField.rx.text.orEmpty.asObservable(),
                                                 touchUp: loginButton.rx.controlEvent(.touchUpInside)))
        
     viewModel.loginResult.subscribe(onNext: { (result) in
         if result == true {
             print(&quot;登录成功&quot;)
         }else{
             print(&quot;登录失败&quot;)
         }
     }).disposed(by: disposeBag)
 }
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这样一个登录功能就基本完成了，相信看完上面的代码，肯定也会有很多疑问。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Observable.just(...)&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;Observable.create { }&lt;/code&gt;是干什么用的？ &lt;br /&gt;
这些方法都是拿来将对象包装成可观察的序列，更多的构建方法可以参考&lt;a href=&quot;https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html&quot;&gt;这里&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;observer.onNext(...)&lt;/code&gt;又是干什么用的？&lt;br /&gt;
observer是&lt;code class=&quot;highlighter-rouge&quot;&gt;AnyObserver&amp;lt;...&amp;gt;&lt;/code&gt;类型，当使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Observable.create { }&lt;/code&gt;创建序列的时候，闭包内会返回&lt;code class=&quot;highlighter-rouge&quot;&gt;AnyObserver&amp;lt;...&amp;gt;&lt;/code&gt;对象,&lt;code class=&quot;highlighter-rouge&quot;&gt;AnyObserver&amp;lt;...&amp;gt;&lt;/code&gt;对象允许你通过&lt;code class=&quot;highlighter-rouge&quot;&gt;.onNext(...)&lt;/code&gt;发出一个元素，&lt;code class=&quot;highlighter-rouge&quot;&gt;onError(...)&lt;/code&gt;发出一个错误，&lt;code class=&quot;highlighter-rouge&quot;&gt;onCompleted()&lt;/code&gt;通知任务已经完成。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;参考&quot;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxSwift/blob/master/Documentation/Why.md&quot;&gt;RxSwift官方文档&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://beeth0ven.github.io/RxSwift-Chinese-Documentation/&quot;&gt;RxSwift中文文档&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 06 May 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/05/06/RxSwift%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-%E5%BC%80%E7%AF%87/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/05/06/RxSwift%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83-%E5%BC%80%E7%AF%87/</guid>
        
        <category>RxSwift</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>引起懒加载多次的问题思考</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;懒加载是为了保证属性只会初始化一次，同时在没有使用时，节能内存而使用的。苹果也非常推荐我们使用。但是今天在使用的时候，发现居然会懒加载了2次，为了更容易让别人看懂，我精炼了以下的代码，更好解释为什么会出现懒加载2次的情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;class BViewController: UIViewController {

    lazy var bgView: UIView = {
        var bgView = UIView()
        view.addSubview(bgView)
        print(bgView)
        return bgView
    }()
    
    init(color :UIColor) {
        super.init(nibName: nil, bundle: nil)
        bgView.backgroundColor = color
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        bgView.frame = view.frame
        
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设这时候AController通过&lt;code class=&quot;highlighter-rouge&quot;&gt;init(color :UIColor)&lt;/code&gt;调用BController push进来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;        let bvc = BViewController(color: .red)
        present(bvc, animated: true, completion: nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先来思考一下，bvc会是什么颜色？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;答案是:黑色的(友情提示：Controller没有设置View颜色的时候，默认黑色)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这时候看一下打印信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-LLVM&quot;&gt;&amp;lt;UIView: 0x7f97e0602fa0; frame = (0 0; 0 0); layer = &amp;lt;CALayer: 0x60000022c2e0&amp;gt;&amp;gt;
&amp;lt;UIView: 0x7f97e06098b0; frame = (0 0; 0 0); layer = &amp;lt;CALayer: 0x60000022be60&amp;gt;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原来是因为bgView进行了两次懒加载，先讲下怎么解决这个问题，后面会详细分析原因，引起这个问题的原因其实就是因为这一行&lt;code class=&quot;highlighter-rouge&quot;&gt;view.addSubview(bgView)&lt;/code&gt;,此时把&lt;code class=&quot;highlighter-rouge&quot;&gt;view.addSubview(bgView)&lt;/code&gt;放到&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad()&lt;/code&gt;再次运行，打印信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-LLVM&quot;&gt;&amp;lt;UIView: 0x7fb94ac0e6b0; frame = (0 0; 0 0); layer = &amp;lt;CALayer: 0x604000224020&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题解决！&lt;br /&gt;
为了方便解释，我特地画了个图来解释第一次代码的生命周期：&lt;br /&gt;
&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/2018-3-21-lazy-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;换到第二个方式之后，就简单多了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/2018-3-21-lazy-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从这个问题，可以猜测Controller的view在生成的时候就会触发&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt;,为了避免出现这样的问题，还是应该尽量少在Controller的初始化方法里进行操作。&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/03/21/%E5%BC%95%E8%B5%B7%E6%87%92%E5%8A%A0%E8%BD%BD%E5%A4%9A%E6%AC%A1%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/03/21/%E5%BC%95%E8%B5%B7%E6%87%92%E5%8A%A0%E8%BD%BD%E5%A4%9A%E6%AC%A1%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/</guid>
        
        <category>问题随笔</category>
        
        <category>iOS</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>2018</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;正好今天跟前同事聊到工作的事情，前同事得到了阿里的面试，聊到还是得三年工作经验才能有BAT的面试，有感而发，想聊聊过去做了什么，未来想做什么，为后面的BAT做铺垫。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;工作&quot;&gt;工作&lt;/h1&gt;
&lt;p&gt;在2017年的9月，从深圳来到了广州，脱离了无休止的加班，来到万表之后终于有时间做自己的事情了。&lt;/p&gt;

&lt;h1 id=&quot;swiftffdb&quot;&gt;SwiftFFDB&lt;/h1&gt;
&lt;p&gt;空闲下来之后，基本全身心的放在了&lt;a href=&quot;https://github.com/fidetro/swift-ffdb&quot;&gt;SwiftFFDB&lt;/a&gt;身上，在做&lt;code class=&quot;highlighter-rouge&quot;&gt;SwiftFFDB&lt;/code&gt;的时候也暴露出swift不少的缺点，不够完善的反射，协议没办法像继承一样在方法推断返回self类型等等。当然，优点更大于缺点，协议编程，函数编程，extension，这些都是&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;所没有的。在设计&lt;code class=&quot;highlighter-rouge&quot;&gt;SwiftFFDB&lt;/code&gt;的时候，看过安卓的&lt;a href=&quot;https://github.com/LitePalFramework/LitePal&quot;&gt;LitePal&lt;/a&gt;,由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;语言本身就非常适合链式编程，所以在&lt;code class=&quot;highlighter-rouge&quot;&gt;SwiftFFDB&lt;/code&gt;底层的时候，就参考了&lt;code class=&quot;highlighter-rouge&quot;&gt;LitePal&lt;/code&gt;,通过SQL语句中的增删改查的类组成。其余用起来和原本的OC版本是差不多的，也算在前天把该写的单元测试也写完了，感觉稍微满意了，发布了1.x版本，回头一看才发现，距离第一个release的版本已经半年了，OC版的已经快一年了，虽然没有很多人使用，只是自己圈子内的朋友在用，维护了这么久的一个项目，怎么说呢，还是挺有意思的，从一个数据库白痴，到了现在的数据库小白，跟着自己的项目一起成长。&lt;/p&gt;

&lt;h1 id=&quot;成长&quot;&gt;成长&lt;/h1&gt;
&lt;p&gt;当了程序员之后，就觉得自己学习没有停过，可有效的，可持续的使用的知识在最近这段时间却很少，一开始我以为只是因为自己的学习又出现了疲倦期，然后找了个周末去了趟珠海，坐在海边看了2天海，浮躁的心思的确平稳了下去。可回到来没几天，还是没静下心来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://foolishtalk.oss-cn-shenzhen.aliyuncs.com/IMG_3620%2820180121-092122%29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在想想，还是学习方法出了问题。最初因为在弄swift服务端的时候，学了下shell，觉得脚本很方便，然后跑去看了几天python，后来微信的&lt;code class=&quot;highlighter-rouge&quot;&gt;WCDB&lt;/code&gt;Swift版也出来了，据说还是改了sqlite源码上做的，比起自己在&lt;code class=&quot;highlighter-rouge&quot;&gt;FMDB&lt;/code&gt;基础上做要厉害多了，然后又跑去系统的学了下C语言，打算阅读源码，后来刚好自己的SS客户端出了问题，那时候在想，如果这客户端是我写的多好，那样我就知道是哪里出问题了，抱着这个想法又去写了个SS客户端，在写的时候才真正认识到自己在网络编程这一块的知识是有多么的薄弱，很多没有概念，然后又下决心去补网络编程，最后虽然是借助&lt;code class=&quot;highlighter-rouge&quot;&gt;NEKit&lt;/code&gt;完成了，然而原理都不懂。&lt;br /&gt;
有想法去学这些，我觉得挺好的，但是想法变得太快，这几件事情都让我明白一点，自己现在的基础知识是有多么的匮乏。&lt;/p&gt;

&lt;h1 id=&quot;三年&quot;&gt;三年&lt;/h1&gt;
&lt;p&gt;很多人都说，程序员三年是一个转折点，从目前附近的朋友了解到的情况，似乎的确是这样的。我打算给自己立flag，距离自己三年，还差大概一年二个多月的样子，学习语言上，应该不再会被别的分心，专心的好好搞一下C，能读读源码的水平吧，基础上，希望半年内把«http权威指南»和«深入理解计算机系统»读完吧，今年一定填完上心留下的坑，希望到了三年的时候去BAT面试的自己，依旧能因为自身的水平，而保持过往面试的从容和自信，不留遗憾。&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/03/18/2018/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/03/18/2018/</guid>
        
        <category>杂谈</category>
        
        
      </item>
    
      <item>
        <title>用Swift打造一个轻量级POP的网络请求库</title>
        <description>&lt;p&gt;我从&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;转到&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;已经有好些时间了，&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;起码在iOS开发这块，开源组件已经很完善，为什么还要再造轮子呢？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;目的只有一个，为了简化对业务层的操作。&lt;br /&gt;
事实上，在写这篇文章的时候，这个&lt;a href=&quot;https://github.com/Fidetro/PSea&quot;&gt;轮子&lt;/a&gt;已经做好了,所以来聊聊他做了什么：&lt;br /&gt;
在&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;时候我所遇到很多网络层都是这样的结构:&lt;/p&gt;
  &lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt; ______________
|              |
| AFNetWorking | 
|______________|
        |
        |
        v
 ______________
|              |
|  APIManager  | 
|______________|
        |
        |
        v
 ______________
|              |
|  Controller  | 
|______________|        
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后APIManager只管请求，然后回调都在Controller上处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;successHanlder:^(NSDictonary *dict){
//转模型
Model *model = [Model jsonToModel:dict];
if (model.errorCode == 0) {
    //数据加工
    //刷新页面
}else{
    //处理错误
    //错误显示
}

} errorHanlder:^(NSDictionry *dict,NSError *error){

};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结一下关于业务层能抽象出来的部分有哪些呢？&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;判断数据是否正确&lt;/li&gt;
  &lt;li&gt;转成数据模型&lt;/li&gt;
  &lt;li&gt;处理业务错误&lt;/li&gt;
  &lt;li&gt;错误提示&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;知道要解决的问题之后，剩下就是怎么去解决了，还在用&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;的时候，使用过&lt;code class=&quot;highlighter-rouge&quot;&gt;YTKNetwork&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;YTKNetwork&lt;/code&gt;是用继承解决的，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;中更推荐使用&lt;code class=&quot;highlighter-rouge&quot;&gt;protocol&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;extension&lt;/code&gt;这套组合拳来解决问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;如果说是网络请求库可能不太准确，它更像是一种思想，它依赖&lt;code class=&quot;highlighter-rouge&quot;&gt;Alamofire&lt;/code&gt;,介于网络层和业务通用层之间的媒介。在这基础上，我给他增加了链式，让他更加Swiftly一点。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;基本设置&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;public protocol PSea: class {

    /// 请求方式
    func method() -&amp;gt; HTTPMethod
    /// 设置域名
    func baseURL() -&amp;gt; String
    /// 请求路由
    func requestURI() -&amp;gt; String
    /// 请求参数
    func parameters() -&amp;gt; Parameters?
    /// 请求头
    func headers() -&amp;gt; HTTPHeaders?
    /// 参数编码
    func encoding() -&amp;gt; ParameterEncoding
    
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这部分是http最基本的支持，用法如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    public func headers() -&amp;gt; HTTPHeaders? {
        return [&quot;Content-type&quot;:&quot;application/json&quot;,
                &quot;Accept&quot;:&quot;application/json&quot;]
    }
    func baseURL() -&amp;gt; String {
        return &quot;http://localhost:23333&quot;
    }
    public func parameters() -&amp;gt; Parameters? {
        return [&quot;hello&quot;:&quot;world&quot;]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    func complete(_ completionHandler: @escaping ((DataResponse&amp;lt;Any&amp;gt;) -&amp;gt; ()))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;    func complete(_ completionHandler: @escaping ((DataResponse&amp;lt;Any&amp;gt;) -&amp;gt; ()))&lt;/code&gt;是和&lt;code class=&quot;highlighter-rouge&quot;&gt;Alamofire&lt;/code&gt;接触，实现请求的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    func successParse(response: DataResponse&amp;lt;Any&amp;gt;)
    func errorParse(response: DataResponse&amp;lt;Any&amp;gt;)
    func failureParse(response:DataResponse&amp;lt;Any&amp;gt;,error: Error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个是&lt;code class=&quot;highlighter-rouge&quot;&gt;protocol&lt;/code&gt;中的接口，需要遵循&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;的类去解析&lt;br /&gt;
整个&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;目前100行代码不到，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;只提供了把&lt;code class=&quot;highlighter-rouge&quot;&gt;Alamofire&lt;/code&gt;的用法转成的POP，具体涉及业务层是需要通过遵循&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;再衍生出一个业务类，还是废话少说，上代码。&lt;/p&gt;

&lt;p&gt;就拿我个人项目来讲&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;
public protocol PetRequest : PSea {
   /// 是否需要token
    func needToken() -&amp;gt; Bool
    /// 请求参数
    func petParameters() -&amp;gt; Parameters?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;func needToken()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;func petParameters()&lt;/code&gt;都是对外需要重写的，可以先不管&lt;br /&gt;
接下来是把&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;需要重写的接口，实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;extension PetRequest {
    public func headers() -&amp;gt; HTTPHeaders? {
        return [&quot;Content-type&quot;:&quot;application/json&quot;,
                &quot;Accept&quot;:&quot;application/json&quot;]
    }
    func baseURL() -&amp;gt; String {
        return &quot;设置域名&quot;
    }
    public func parameters() -&amp;gt; Parameters? {
        //对参数进行处理
        let params = petParameters()    
    
        return params
    }
    
    public func encoding() -&amp;gt; ParameterEncoding {
        if method() == .get {
            return URLEncoding(destination: .methodDependent)
        }else{
            return JSONEncoding.default
        }
    }
    
    //成功结果的解析
    func successParse(response:DataResponse&amp;lt;Any&amp;gt;){
        guard let value = response.result.value as? [String:Any],
            let _ = value[&quot;errcode&quot;] as? Int else{
                return
        }
        if let handler = self.successHandler {
            handler(response,value)
        }else{
            //成功不处理
        }
    }
    //请求成功，但结果不是我们需要的解析
    func errorParse(response:DataResponse&amp;lt;Any&amp;gt;){
        guard let value = response.result.value as? [String:Any],
            let code = value[&quot;errcode&quot;] as? Int else{
                return
        }
        let errmsg = value[&quot;errmsg&quot;] as? String
        guard code == 0 else {
            if let handler = self.errorHandler {
                handler(response,code,errmsg ?? &quot;&quot;)
            }else{
                //不处理的时候会提示
                SVProgressHUD.showError(withStatus: errmsg ?? &quot;&quot;)
            }
            return
        }
    }
    //网络错误的解析
    func failureParse(response: DataResponse&amp;lt;Any&amp;gt;, error: Error) {
        guard let _ = response.result.value as? [String:Any] else{
            if let handler = self.failureHandler {
                handler(response,error)
            }else{
                //TODO: 提示请求超时
                SVProgressHUD.showError(withStatus: &quot;网络连接超时&quot;)
            }
            return
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;设计好了一个简单的POP网络请求库，再举一个简单的登录api使用例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;class LoginApi: PetRequest {

    var username : String = &quot;xxx&quot;
    var password : String = &quot;xxx&quot;
    var successHandler: SccuessCallBack?    
    var errorHandler: ErrorCallBack?
    var failureHandler: FailureCallBack?

    func needToken() -&amp;gt; Bool {
        return false
    }

    func petParameters() -&amp;gt; Parameters? {
        return [&quot;username&quot;:username,
                &quot;password&quot;:password]
    }
    
    func method() -&amp;gt; HTTPMethod {
        return .post
    }
    
    func requestURI() -&amp;gt; String {
        return &quot;/petday/login&quot;
    }
  
}

//使用例子
        LoginApi().request().success { (_, value) in
            
            }.failure { (_, _, _) in
                
                
            }.error { (_, _, _) in                
                
        }

然后又因为failure和error都已经经过业务层做处理了，不是特殊情况下，不需要额外做处理，又可以简写成
        LoginApi().request().success { (_, value) in
            
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外如果需要将成功的结果返回的时候转成对象，
首先在处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;func successParse(response: DataResponse&amp;lt;Any&amp;gt;) {
           guard let value = response.result.value as? [String:Any] else{
                return
        }
    //经过处理一系列结果
    //...
    //...
    let modelJSON =  //...需要转换成对象的合法JSON字典
        if let handler = self.successHandler {
            handler(modelJSON,value)
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后可以写成这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;ListApi().request().success(ListModel.self) { (model,value) in

}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 09 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/03/09/aasdasd/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/03/09/aasdasd/</guid>
        
        <category>Swift-Tips</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>Swift高阶函数的使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文内容基于Swift 4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在读《Swift进阶》的时候发现,Swift提供了很多内置的高阶函数用于数组变形，使用高阶函数最大优势在于，用更少量的代码去解决问题。&lt;/p&gt;
&lt;h1 id=&quot;map&quot;&gt;map&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let a = [1,2,3,4,5,6]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要把这个数组中的元素每个都+1，按照以前的做法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;var b = [Int]()
    for ele in a {
        b.append(ele+1)
    }
    print(b)//[2,3,4,5,6,7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但使用map之后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let b = a.map { (ele) -&amp;gt; Int in
        return ele+1
    }
    print(b)//[2,3,4,5,6,7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时也因为&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;闭包的特性，上面的代码还可以写成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let b = a.map{
        $0+1
    }
    print(b)//[2,3,4,5,6,7]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;flatmap&quot;&gt;flatMap&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;的用法很相像，通过对比两者的不难发现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;public func map&amp;lt;T&amp;gt;(_ transform: (Element) throws -&amp;gt; T) rethrows -&amp;gt; [T]

public func flatMap(_ transform: (Element) throws -&amp;gt; String?) rethrows -&amp;gt; [String]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;允许返回&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;值，对元素进行过滤再变形&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;可以将多维数组转成一维数组
    &lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let a = [[1,2,3],[4,5,6]]
 let b = a.flatMap {
     $0
 }
 print(b)//[1,2,3,4,5,6]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;filter&quot;&gt;filter&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;用于过滤元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,5,6]
    //去掉a数组内&amp;lt;4的元素
    let b = a.filter { (value) -&amp;gt; Bool in
        return value &amp;gt; 4
    }
    print(b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;reduce&quot;&gt;reduce&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;可以将数组中的元素合并到一个值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let a = [1,2,3,4,5,6]
//如果要将a数组内所有元素相加，再+7，以前的写法是这样：
let count = 0
for value in a {
   count += value
}
count += 7
print(count)//28
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用reduce之后，事件就变得非常简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let b = a.reduce(7) { (count, value) -&amp;gt; Int in
        return count+value
    }
    print(b)//28
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;sequence&quot;&gt;sequence&lt;/h1&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sequence&lt;/code&gt;可以生成无限的序列
假设我们要从遍历从0到100的偶数，以前的写法是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    for i in 0..&amp;lt;26 {
        print(i*2) //0,2,4...48,50
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;sequence&lt;/code&gt;只需要:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    for i in sequence(first: 0, next: {$0+2}) {
        if i&amp;gt;50 {
            break
        }
        print(i) //0,2,4...48,50
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;sorted&quot;&gt;sorted&lt;/h1&gt;
&lt;p&gt;用于排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;//倒序
    let a = [1,2,3,4,5,6]
    let b =  a.sorted { (next, last) -&amp;gt; Bool in
        return next &amp;gt; last
    }
    print(b)//[6, 5, 4, 3, 2, 1]

    //根据字母顺序倒序
    let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
    let descendingStudents = students.sorted(by: &amp;gt;)
    print(descendingStudents)
    // Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;split&quot;&gt;split&lt;/h1&gt;
&lt;p&gt;分割数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,5,6]
    //按照0分割数组，数组中没有0
    let b =  a.split(separator: 0)
    print(b[0])//[1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,3,6]
    //按照3分割数组
    let b =  a.split(separator: 3)
    print(b)//[ArraySlice([1, 2]), ArraySlice([4]), ArraySlice([6])]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;prefix&quot;&gt;prefix&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prefix&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;类似，过滤条件为true的时候会到结果中，区别在于，当为false的时候会直接结束&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,3,6]
    let b =  a.prefix(upTo: 4)
    print(b)//[1,2,3,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;drop&quot;&gt;drop&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;drop&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;prefix&lt;/code&gt;相反，当为true的时候元素会被丢弃，为false的时候会直接结束&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,3,6]
    let b =  a.drop(while: { (value) -&amp;gt; Bool in
        if value &amp;lt; 3 {
            return true
        }
        return false
    })
     print(b)//[3, 4, 3, 6]
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/03/06/Swift%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/03/06/Swift%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
        
        <category>Swift-Tips</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>AVCaptureSession自定义相机获取的UIImage旋转无效</title>
        <description>&lt;p&gt;在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;AVCaptureSession&lt;/code&gt;自定义相机的时候，发现无论横竖拍出来，照片的方向总是不对，参考了下面的两个链接的方法依旧行不通，然后自己想了个办法去解决。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/39705993/is-uiimage-imagewithciimagescaleorientation-broken-on-ios10&quot;&gt;is-uiimage-imagewithciimagescaleorientation-broken-on-ios10&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1315251/how-to-rotate-a-uiimage-90-degrees/30703714#30703714&quot;&gt;how-to-rotate-a-uiimage-90-degrees&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过使用重力加速计判断手机旋转的方向，再去设置&lt;code class=&quot;highlighter-rouge&quot;&gt;AVCaptureConnection&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;videoOrientation&lt;/code&gt;属性，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;@interface FIDCameraHelper ()
@property (nonatomic,strong) CMMotionManager *motionManager;
@property (nonatomic,assign) UIImageOrientation orientation;
@end
@implementation FIDCameraHelper
- (CMMotionManager *)motionManager
{
    if (!_motionManager)
    {
        _motionManager = [[CMMotionManager alloc]init];
    }
    return _motionManager;
}

//启动重力加速计
+ (void)startUpdateAccelerometerResult:(void (^)(UIImageOrientation orientation))result
{   
    if ([sharedManager.motionManager isAccelerometerAvailable] 
        [sharedManager.motionManager setAccelerometerUpdateInterval:0.1];
        [sharedManager.motionManager startAccelerometerUpdatesToQueue:[NSOperationQueue currentQueue] withHandler:^(CMAccelerometerData *accelerometerData, NSError *error)
         {
             double x = accelerometerData.acceleration.x;
             double y = accelerometerData.acceleration.y;
             if (fabs(y) &amp;gt;= fabs(x))
             {
                 if (y &amp;gt;= 0){
                     //Down
                     if (result) {
                         result(UIImageOrientationDown);
                     }
                 }
                 else{
                     //Portrait
                     if (result) {
                         result(UIImageOrientationUp);
                     }
                 }
             }
             else
             {
                 if (x &amp;gt;= 0){
                     //Right
                     if (result) {
                         result(UIImageOrientationRight);
                     }
                 }
                 else{
                     //Left
                     if (result) {
                         result(UIImageOrientationLeft);
                     }
                 }
             }
         }];
    }
}

- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection
{
    
    CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
    CFDictionaryRef attachments = CMCopyDictionaryOfAttachments(kCFAllocatorDefault, sampleBuffer, kCMAttachmentMode_ShouldNotPropagate);
    CIImage *ciImage = [[CIImage alloc] initWithCVPixelBuffer:pixelBuffer options:(NSDictionary *)CFBridgingRelease(attachments)];
    //根据方向设置videoOrientation
    switch (self.orientation) {
        case UIImageOrientationUp:
        {
            connection.videoOrientation = AVCaptureVideoOrientationPortrait;
            break;
        }
        case UIImageOrientationDown:
        {
            connection.videoOrientation = AVCaptureVideoOrientationPortraitUpsideDown;
            break;
        }
        case UIImageOrientationLeft:
        {
            connection.videoOrientation = AVCaptureVideoOrientationLandscapeRight;
            break;
        }
        case UIImageOrientationRight:
        {
            connection.videoOrientation = AVCaptureVideoOrientationLandscapeLeft;
            break;
        }
        default:
            break;
    }
    self.cameraImage = [UIImage imageWithCIImage:ciImage scale:1.0 orientation:self.orientation];
}

@end
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/03/06/AVCaptureSession%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA%E8%8E%B7%E5%8F%96%E7%9A%84UIImage%E6%97%8B%E8%BD%AC%E6%97%A0%E6%95%88/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/03/06/AVCaptureSession%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA%E8%8E%B7%E5%8F%96%E7%9A%84UIImage%E6%97%8B%E8%BD%AC%E6%97%A0%E6%95%88/</guid>
        
        <category>iOS</category>
        
        <category>问题随笔</category>
        
        
      </item>
    
      <item>
        <title>Swift-Tips String截取字符串</title>
        <description>&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;中我们可以使调&lt;code class=&quot;highlighter-rouge&quot;&gt;substringWithRange&lt;/code&gt;的方法达到截取字符串的效果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[@&quot;123&quot; substringWithRange:NSMakeRange(1, 2)];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Swift 4之前，也是有类似的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ss&quot;.substring(with: &amp;lt;Range&amp;lt;String.Index&amp;gt;&amp;gt;)&lt;/code&gt;  ,但是在Swift 4之后被弃用了，我们可以通过用&lt;code class=&quot;highlighter-rouge&quot;&gt;extension&lt;/code&gt;的方法去给他增加截取字符串的方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension String{
    func to(_ index:Int) -&amp;gt; String? {
        let toIndex = String.Index.init(encodedOffset: index)
        guard toIndex &amp;lt; self.endIndex else { return nil }
        return String(self[...toIndex])
        
    }
    func from(_ index:Int) -&amp;gt; String? {
        let fromIndex = String.Index.init(encodedOffset: index)
        guard fromIndex &amp;lt; self.endIndex else { return nil }
        return String(self[fromIndex..&amp;lt;self.endIndex])
    }
    func subString(_ from:Int,to:Int) -&amp;gt; String? {
        let toIndex = String.Index.init(encodedOffset: from)
        let fromIndex = String.Index.init(encodedOffset: to)
        guard toIndex &amp;lt; self.endIndex,
            fromIndex &amp;lt; self.endIndex,
            toIndex &amp;lt;= fromIndex else { return nil }
        return String(self[toIndex...fromIndex])
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在又可以方便的截取字符串了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(&quot;12345678&quot;.to(3)) //Optional(&quot;1234&quot;)  

print(&quot;12345678&quot;.from(3)) //Optional(&quot;45678&quot;)  

print(&quot;12345678&quot;.subString(3, to: 5))  //Optional(&quot;456&quot;)  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外我们还可以结合Swift下标的特性，达到通过取字符串下标截取字符串&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension String{
    subscript(index:Int) -&amp;gt; String? {
        return subString(index, to: index)
    }
    subscript (bounds: CountableClosedRange&amp;lt;Int&amp;gt;) -&amp;gt; String? {
        return subString( bounds.lowerBound, to: bounds.upperBound)
    }
    subscript (bounds: CountableRange&amp;lt;Int&amp;gt;) -&amp;gt; String? {
        return subString( bounds.lowerBound, to: bounds.upperBound)
    }   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(&quot;12345678&quot;[2])  //Optional(&quot;3&quot;)  

print(&quot;12345678&quot;[3...5])  //Optional(&quot;456&quot;)

print(&quot;12345678&quot;[100])  //nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/01/29/Swift-Tips-String%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/01/29/Swift-Tips-String%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
        
        <category>Swift-Tips</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>浅谈iOS在物联网应用中的架构</title>
        <description>&lt;p&gt;这篇文章在很早之前就在酝酿，我目前的开发生涯中，在现在这间公司之前，都是和硬件打交道的，期间踩了很多坑，尝试了很多不同方式的写法和架构的改变，因此有了些经验，可能文中的一些点大家都比较熟悉，只是在处理上略有不同，接下来我会分享一下自己的做法，作为对自己在iOS物联网方面一个短暂的总结吧。如果有什么不同的意见，也可以在评论区留下评论，可以一起探讨一下问题。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;物联网在ios上的表现无非两种&quot;&gt;物联网在iOS上的表现，无非两种&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;WiFi&lt;/li&gt;
  &lt;li&gt;蓝牙&lt;br /&gt;
而这两种表现形式，在做的事情无非就是：&lt;br /&gt;
&lt;img src=&quot;http://foolishtalk.oss-cn-shenzhen.aliyuncs.com/2345604-7134da016a716ebf.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://foolishtalk.oss-cn-shenzhen.aliyuncs.com/0C1F4A7B-90A5-4CB1-B51A-A06A48116480.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;硬件和App之间如何通讯实现交互不属于本文讨论的范畴，因为其表现形式都会像上图一样。从代码层上来讲，通讯这部分都应该封装成一个类，外部无需知道内容是如何实现，业务方只需要得到设备返回的数据以及将数据发送给设备就可以了，类似于下面这样:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeviceDataManagerDelegate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  这里的device他可以是蓝牙的外设，也可以是能某种能标示设备的tag，能get到点就可以了
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeviceDataManager&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sendData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;为了下面的内容更好理解，避免和http请求的网络层混淆，我把这一层叫作&lt;code class=&quot;highlighter-rouge&quot;&gt;传输层&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;网络层&lt;/code&gt;中，我们一般会根据业务对网络请求进行封装，避免重复写处理非正常结果时的代码，传输层中并不能像网络层一样能直接使用得到的数据，传输层中得到一般都是经过自定的协议包装加密过后的数据，而不像网络层使用JSON那么方便，抛开自定义的协议来讲，物联网中传输层最基本的内容都会由以下的组成：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;传输层数据
│
├────命令字(功能)
├────消息体(行为)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在得到这部分数据之后，我们会经过根据事先与硬件方约定好的协议去进行解析，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0100&lt;/code&gt;这个数据代表了什么：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;           开关（功能）  状态（行为）
传输层数据    0x01         0x00 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这部分数据看起来十分简单，但是对于一个完全没有看过事先与硬件方约定好的协议来说，是非常难懂的。&lt;br /&gt;
在我当时团队的code review的时候，也发现了因此带来的一些问题：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.随着版本更新，新的协议增加导致数据变得越来越庞大，接手的同学一脸懵逼;
2.处理数据后，通知满天飞，甚至没有处理消息体直接丢;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;del&gt;对于第一个问题，我曾经有考虑过使用一门语言作出通用的解析库，硬件端、移动端、前端、后台如果需要解析这个数据，只需要传入传输层数据，返回的就是JSON对象这样的一个方案。想象中挺美好的，但是这样也会带来解析库的维护成本以及额外的文档，后来还是放弃了这个做法。&lt;/del&gt;&lt;br /&gt;
 在第一的问题上，最终还是老老实实的手动解析成model。&lt;br /&gt;
 造成第二个问题，很大程度也是因为团队里没有约定很好的代码规范导致的。在当时，我还没有很深入的了解过AOP，选择的是在一开始处理完数据之后，会用另外一个model的block去接收，然后另外在controller去订阅，这种做法有个弊端就是代码量十分多，后来我了解到了&lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;之后，我强烈推荐使用&lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;去解决这个问题，这里用AOP好处是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;不需要再管理通知的监听和移除,也因此避免了通知带来的没有释放控制器的问题;&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;，代码会变得更加整洁和少;&lt;br /&gt;
空说无益，还是直接上图吧&lt;br /&gt;
&lt;img src=&quot;http://foolishtalk.oss-cn-shenzhen.aliyuncs.com/D45F4AE5-5D7F-4C98-9AB9-B26886FFC8FF.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;的框架，我看了网上也有很多，大部分是在&lt;a href=&quot;https://github.com/steipete/Aspects&quot;&gt;Aspects&lt;/a&gt;的基础上封装的，更推荐直接去使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Aspects&lt;/code&gt;,像是一些发送队列，几秒内只接收一个，几秒内只处理最后一个这种需求，都比较方便，当然也用&lt;code class=&quot;highlighter-rouge&quot;&gt;RAC&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;RxSwift&lt;/code&gt;处理，见仁见智。&lt;/p&gt;

&lt;p&gt;怕讲的太抽象，放一段使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Aspects&lt;/code&gt;的伪代码：&lt;/p&gt;

&lt;p&gt;Action的伪实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TAction&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//处理数据
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;hello action&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Store的伪代码实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TStore&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;handler_block&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object_getClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TAction&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;aspect_hookSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withOptions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AspectPositionAfter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usingBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AspectInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspectInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aspectInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;originalInvocation&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getReturnValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;handler_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Controller上，我们就只需要订阅Store的消息就可以了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TStore&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;物联网除了还会有很多关于网络层的小坑以外，别的就和其他领域的也差不多了，所以也不想说太多老生常谈的东西，就这样。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/01/16/%E6%B5%85%E8%B0%88iOS%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E6%9E%B6%E6%9E%84/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/01/16/%E6%B5%85%E8%B0%88iOS%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E6%9E%B6%E6%9E%84/</guid>
        
        <category>架构</category>
        
        <category>物联网</category>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>在UITableView中使用RunLoop遇到的坑</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在做Pet Day的时候，遇到一个这样的需求，假定&lt;code class=&quot;highlighter-rouge&quot;&gt;tableView&lt;/code&gt;中的section初始值为50,在往上或者往下的时候，需要通过计算得知更多的&lt;code class=&quot;highlighter-rouge&quot;&gt;dataSource&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后我一开始的做法，是在&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;的方法在接近顶部或者接近底部的时候，进行计算&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    func tableView(_ tableView: UITableView,
                   willDisplay cell: UITableViewCell,
                   forRowAt indexPath: IndexPath) {
        //如果大于数据源总数-30，需要开始计算后面的内容
        if indexPath.section &amp;gt; dataSource.count - 30 {
           
        }else if indexPath.section &amp;lt; 30 {//如果小于30，需要开始计算前面的内容
           
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;但是，这样做会有问题&lt;/strong&gt;，在遇到向上刷新的时候，会多次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;的方法，导致数据突然增多。&lt;/p&gt;

&lt;p&gt;后来用定时器实现触发后0.5秒内拦截，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   guard share.operations.contains(tag) == false else {
            return
        }
        let timer = Timer.bs_scheduledTimer(withTimeInterval: interval, block: { (timer) in
            weak var weakTimer = timer

            weakTimer?.invalidate()
            weakTimer = nil
        }, repeats: false)
        share.operations.insert(tag)
        timer.fire()
        shareRunLoop().add(timer, forMode: .defaultRunLoopMode)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;这时候runloop的坑就来了&quot;&gt;&lt;strong&gt;这时候RunLoop的坑就来了&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;第一次触发…正常&lt;br /&gt;
第二次触发…0.5秒过了，好几秒过去了，还是没有反应&lt;br /&gt;
…&lt;br /&gt;
终于在停止刷新后，再往上刷，正常了&lt;/p&gt;

&lt;p&gt;我自己的推测是因为tableView在刷新的过程中，tableView的刷新事件比定时器的事件先进，需要等刷新停止了，定时器才能执行&lt;br /&gt;
然后换了另外一种实现方式就没问题了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        
        guard share.operations.contains(tag) == false else {
            return
        }
            operation()
        
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + interval, execute: {
            share.operations.remove(tag)
        })
        
        share.operations.insert(tag)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 12 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://www.foolishtalk.org/2018/01/12/%E5%9C%A8UITableView%E4%B8%AD%E4%BD%BF%E7%94%A8RunLoop%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</link>
        <guid isPermaLink="true">http://www.foolishtalk.org/2018/01/12/%E5%9C%A8UITableView%E4%B8%AD%E4%BD%BF%E7%94%A8RunLoop%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</guid>
        
        <category>问题随笔</category>
        
        <category>RunLoop</category>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
