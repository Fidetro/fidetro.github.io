<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FoolishTalk</title>
    <description></description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 27 Mar 2018 14:24:46 +0800</pubDate>
    <lastBuildDate>Tue, 27 Mar 2018 14:24:46 +0800</lastBuildDate>
    <generator>Jekyll v3.7.0</generator>
    
      <item>
        <title>引起懒加载多次的问题思考</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;懒加载是为了保证属性只会初始化一次，同时在没有使用时，节能内存而使用的。苹果也非常推荐我们使用。但是今天在使用的时候，发现居然会懒加载了2次，为了更容易让别人看懂，我精炼了以下的代码，更好解释为什么会出现懒加载2次的情况。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;class BViewController: UIViewController {

    lazy var bgView: UIView = {
        var bgView = UIView()
        view.addSubview(bgView)
        print(bgView)
        return bgView
    }()
    
    init(color :UIColor) {
        super.init(nibName: nil, bundle: nil)
        bgView.backgroundColor = color
    }
    
    required init?(coder aDecoder: NSCoder) {
        fatalError(&quot;init(coder:) has not been implemented&quot;)
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        bgView.frame = view.frame
        
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;假设这时候AController通过&lt;code class=&quot;highlighter-rouge&quot;&gt;init(color :UIColor)&lt;/code&gt;调用BController push进来&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;        let bvc = BViewController(color: .red)
        present(bvc, animated: true, completion: nil)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先来思考一下，bvc会是什么颜色？&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;答案是：黑色的(友情提示：Controller没有设置View颜色的时候，默认黑色)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;这时候看一下打印信息：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-LLVM&quot;&gt;&amp;lt;UIView: 0x7f97e0602fa0; frame = (0 0; 0 0); layer = &amp;lt;CALayer: 0x60000022c2e0&amp;gt;&amp;gt;
&amp;lt;UIView: 0x7f97e06098b0; frame = (0 0; 0 0); layer = &amp;lt;CALayer: 0x60000022be60&amp;gt;&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;原来是因为bgView进行了两次懒加载，先讲下怎么解决这个问题，后面会详细分析原因，引起这个问题的原因其实就是因为这一行&lt;code class=&quot;highlighter-rouge&quot;&gt;view.addSubview(bgView)&lt;/code&gt;,此时把&lt;code class=&quot;highlighter-rouge&quot;&gt;view.addSubview(bgView)&lt;/code&gt;放到&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad()&lt;/code&gt;再次运行，打印信息如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-LLVM&quot;&gt;&amp;lt;UIView: 0x7fb94ac0e6b0; frame = (0 0; 0 0); layer = &amp;lt;CALayer: 0x604000224020&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;问题解决！&lt;br /&gt;
为了方便解释，我特地画了个图来解释第一次代码的生命周期：&lt;br /&gt;
&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/2018-3-21-lazy-1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;换到第二个方式之后，就简单多了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://foolishtalk.oss-cn-shenzhen.aliyuncs.com/2018-3-21-lazy-2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;从这个问题，可以猜测Controller的view在生成的时候就会触发&lt;code class=&quot;highlighter-rouge&quot;&gt;viewDidLoad&lt;/code&gt;,为了避免出现这样的问题，还是应该尽量少在Controller的初始化方法里进行操作。&lt;/p&gt;
</description>
        <pubDate>Wed, 21 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/21/%E5%BC%95%E8%B5%B7%E6%87%92%E5%8A%A0%E8%BD%BD%E5%A4%9A%E6%AC%A1%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/21/%E5%BC%95%E8%B5%B7%E6%87%92%E5%8A%A0%E8%BD%BD%E5%A4%9A%E6%AC%A1%E7%9A%84%E9%97%AE%E9%A2%98%E6%80%9D%E8%80%83/</guid>
        
        <category>问题随笔</category>
        
        <category>iOS</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>2018</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;正好今天跟前同事聊到工作的事情，前同事得到了阿里的面试，聊到还是得三年工作经验才能有BAT的面试，有感而发，想聊聊过去做了什么，未来想做什么，为后面的BAT做铺垫。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;工作&quot;&gt;工作&lt;/h1&gt;
&lt;p&gt;在2017年的9月，从深圳来到了广州，脱离了无休止的加班，来到万表之后终于有时间做自己的事情了。&lt;/p&gt;

&lt;h1 id=&quot;swiftffdb&quot;&gt;SwiftFFDB&lt;/h1&gt;
&lt;p&gt;空闲下来之后，基本全身心的放在了&lt;a href=&quot;https://github.com/fidetro/swift-ffdb&quot;&gt;SwiftFFDB&lt;/a&gt;身上，在做&lt;code class=&quot;highlighter-rouge&quot;&gt;SwiftFFDB&lt;/code&gt;的时候也暴露出swift不少的缺点，不够完善的反射，协议没办法像继承一样在方法推断返回self类型等等。当然，优点更大于缺点，协议编程，函数编程，extension，这些都是&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;所没有的。在设计&lt;code class=&quot;highlighter-rouge&quot;&gt;SwiftFFDB&lt;/code&gt;的时候，看过安卓的&lt;a href=&quot;https://github.com/LitePalFramework/LitePal&quot;&gt;LitePal&lt;/a&gt;,由于&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;语言本身就非常适合链式编程，所以在&lt;code class=&quot;highlighter-rouge&quot;&gt;SwiftFFDB&lt;/code&gt;底层的时候，就参考了&lt;code class=&quot;highlighter-rouge&quot;&gt;LitePal&lt;/code&gt;,通过SQL语句中的增删改查的类组成。其余用起来和原本的OC版本是差不多的，也算在前天把该写的单元测试也写完了，感觉稍微满意了，发布了1.x版本，回头一看才发现，距离第一个release的版本已经半年了，OC版的已经快一年了，虽然没有很多人使用，只是自己圈子内的朋友在用，维护了这么久的一个项目，怎么说呢，还是挺有意思的，从一个数据库白痴，到了现在的数据库小白，跟着自己的项目一起成长。&lt;/p&gt;

&lt;h1 id=&quot;成长&quot;&gt;成长&lt;/h1&gt;
&lt;p&gt;当了程序员之后，就觉得自己学习没有停过，可有效的，可持续的使用的知识在最近这段时间却很少，一开始我以为只是因为自己的学习又出现了疲倦期，然后找了个周末去了趟珠海，坐在海边看了2天海，浮躁的心思的确平稳了下去。可回到来没几天，还是没静下心来。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://foolishtalk.oss-cn-shenzhen.aliyuncs.com/IMG_3620%2820180121-092122%29.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在想想，还是学习方法出了问题。最初因为在弄swift服务端的时候，学了下shell，觉得脚本很方便，然后跑去看了几天python，后来微信的&lt;code class=&quot;highlighter-rouge&quot;&gt;WCDB&lt;/code&gt;Swift版也出来了，据说还是改了sqlite源码上做的，比起自己在&lt;code class=&quot;highlighter-rouge&quot;&gt;FMDB&lt;/code&gt;基础上做要厉害多了，然后又跑去系统的学了下C语言，打算阅读源码，后来刚好自己的SS客户端出了问题，那时候在想，如果这客户端是我写的多好，那样我就知道是哪里出问题了，抱着这个想法又去写了个SS客户端，在写的时候才真正认识到自己在网络编程这一块的知识是有多么的薄弱，很多没有概念，然后又下决心去补网络编程，最后虽然是借助&lt;code class=&quot;highlighter-rouge&quot;&gt;NEKit&lt;/code&gt;完成了，然而原理都不懂。&lt;br /&gt;
有想法去学这些，我觉得挺好的，但是想法变得太快，这几件事情都让我明白一点，自己现在的基础知识是有多么的匮乏。&lt;/p&gt;

&lt;h1 id=&quot;三年&quot;&gt;三年&lt;/h1&gt;
&lt;p&gt;很多人都说，程序员三年是一个转折点，从目前附近的朋友了解到的情况，似乎的确是这样的。我打算给自己立flag，距离自己三年，还差大概一年二个多月的样子，学习语言上，应该不再会被别的分心，专心的好好搞一下C，能读读源码的水平吧，基础上，希望半年内把«http权威指南»和«深入理解计算机系统»读完吧，今年一定填完上心留下的坑，希望到了三年的时候去BAT面试的自己，依旧能因为自身的水平，而保持过往面试的从容和自信，不留遗憾。&lt;/p&gt;
</description>
        <pubDate>Sun, 18 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/18/2018/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/18/2018/</guid>
        
        <category>杂谈</category>
        
        
      </item>
    
      <item>
        <title>用Swift打造一个轻量级POP的网络请求库</title>
        <description>&lt;p&gt;我从&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;转到&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;已经有好些时间了，&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;起码在iOS开发这块，开源组件已经很完善，为什么还要再造轮子呢？&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;目的只有一个，为了简化对业务层的操作。&lt;br /&gt;
事实上，在写这篇文章的时候，这个&lt;a href=&quot;https://github.com/Fidetro/PSea&quot;&gt;轮子&lt;/a&gt;已经做好了,所以来聊聊他做了什么：&lt;br /&gt;
在&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;时候我所遇到很多网络层都是这样的结构:&lt;/p&gt;
  &lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt; ______________
|              |
| AFNetWorking | 
|______________|
        |
        |
        v
 ______________
|              |
|  APIManager  | 
|______________|
        |
        |
        v
 ______________
|              |
|  Controller  | 
|______________|        
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后APIManager只管请求，然后回调都在Controller上处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;successHanlder:^(NSDictonary *dict){
//转模型
Model *model = [Model jsonToModel:dict];
if (model.errorCode == 0) {
    //数据加工
    //刷新页面
}else{
    //处理错误
    //错误显示
}

} errorHanlder:^(NSDictionry *dict,NSError *error){

};

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;总结一下关于业务层能抽象出来的部分有哪些呢？&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;判断数据是否正确&lt;/li&gt;
  &lt;li&gt;转成数据模型&lt;/li&gt;
  &lt;li&gt;处理业务错误&lt;/li&gt;
  &lt;li&gt;错误提示&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;知道要解决的问题之后，剩下就是怎么去解决了，还在用&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;的时候，使用过&lt;code class=&quot;highlighter-rouge&quot;&gt;YTKNetwork&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;YTKNetwork&lt;/code&gt;是用继承解决的，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;中更推荐使用&lt;code class=&quot;highlighter-rouge&quot;&gt;protocol&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;extension&lt;/code&gt;这套组合拳来解决问题。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;如果说是网络请求库可能不太准确，它更像是一种思想，它依赖&lt;code class=&quot;highlighter-rouge&quot;&gt;Alamofire&lt;/code&gt;,介于网络层和业务通用层之间的媒介。在这基础上，我给他增加了链式，让他更加Swifty一点。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;基本设置
```Swift
public protocol PSea: class {&lt;/p&gt;

    &lt;p&gt;/// 请求方式
func method() -&amp;gt; HTTPMethod
/// 设置域名
func baseURL() -&amp;gt; String
/// 请求路由
func requestURI() -&amp;gt; String
/// 请求参数
func parameters() -&amp;gt; Parameters?
/// 请求头
func headers() -&amp;gt; HTTPHeaders?
/// 参数编码
func encoding() -&amp;gt; ParameterEncoding&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;}&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
这部分是http最基本的支持，用法如下：
```Swift
    public func headers() -&amp;gt; HTTPHeaders? {
        return [&quot;Content-type&quot;:&quot;application/json&quot;,
                &quot;Accept&quot;:&quot;application/json&quot;]
    }
    func baseURL() -&amp;gt; String {
        return &quot;http://localhost:23333&quot;
    }
    public func parameters() -&amp;gt; Parameters? {
        return [&quot;hello&quot;:&quot;world&quot;]
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    func complete(_ completionHandler: @escaping ((DataResponse&amp;lt;Any&amp;gt;) -&amp;gt; ()))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;    func complete(_ completionHandler: @escaping ((DataResponse&amp;lt;Any&amp;gt;) -&amp;gt; ()))&lt;/code&gt;是和&lt;code class=&quot;highlighter-rouge&quot;&gt;Alamofire&lt;/code&gt;接触，实现请求的方法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    func successParse(response: DataResponse&amp;lt;Any&amp;gt;)
    func errorParse(response: DataResponse&amp;lt;Any&amp;gt;)
    func failureParse(response:DataResponse&amp;lt;Any&amp;gt;,error: Error)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这三个是&lt;code class=&quot;highlighter-rouge&quot;&gt;protocol&lt;/code&gt;中的接口，需要遵循&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;的类去解析&lt;br /&gt;
整个&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;目前100行代码不到，因为&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;只提供了把&lt;code class=&quot;highlighter-rouge&quot;&gt;Alamofire&lt;/code&gt;的用法转成的POP，具体涉及业务层是需要通过遵循&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;再衍生出一个业务类，还是废话少说，上代码。&lt;/p&gt;

&lt;p&gt;就拿我个人项目来讲&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;
public protocol PetRequest : PSea {
   /// 是否需要token
    func needToken() -&amp;gt; Bool
    /// 请求参数
    func petParameters() -&amp;gt; Parameters?
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;func needToken()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;func petParameters()&lt;/code&gt;都是对外需要重写的，可以先不管&lt;br /&gt;
接下来是把&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;需要重写的接口，实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;extension PetRequest {
    public func headers() -&amp;gt; HTTPHeaders? {
        return [&quot;Content-type&quot;:&quot;application/json&quot;,
                &quot;Accept&quot;:&quot;application/json&quot;]
    }
    func baseURL() -&amp;gt; String {
        return &quot;设置域名&quot;
    }
    public func parameters() -&amp;gt; Parameters? {
        //对参数进行处理
        let params = petParameters()    
    
        return params
    }
    
    public func encoding() -&amp;gt; ParameterEncoding {
        if method() == .get {
            return URLEncoding(destination: .methodDependent)
        }else{
            return JSONEncoding.default
        }
    }
    
    //成功结果的解析
    func successParse(response:DataResponse&amp;lt;Any&amp;gt;){
        guard let value = response.result.value as? [String:Any],
            let _ = value[&quot;errcode&quot;] as? Int else{
                return
        }
        if let handler = self.successHandler {
            handler(response,value)
        }else{
            //成功不处理
        }
    }
    //请求成功，但结果不是我们需要的解析
    func errorParse(response:DataResponse&amp;lt;Any&amp;gt;){
        guard let value = response.result.value as? [String:Any],
            let code = value[&quot;errcode&quot;] as? Int else{
                return
        }
        let errmsg = value[&quot;errmsg&quot;] as? String
        guard code == 0 else {
            if let handler = self.errorHandler {
                handler(response,code,errmsg ?? &quot;&quot;)
            }else{
                //不处理的时候会提示
                SVProgressHUD.showError(withStatus: errmsg ?? &quot;&quot;)
            }
            return
        }
    }
    //网络错误的解析
    func failureParse(response: DataResponse&amp;lt;Any&amp;gt;, error: Error) {
        guard let _ = response.result.value as? [String:Any] else{
            if let handler = self.failureHandler {
                handler(response,error)
            }else{
                //TODO: 提示请求超时
                SVProgressHUD.showError(withStatus: &quot;网络连接超时&quot;)
            }
            return
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就通过&lt;code class=&quot;highlighter-rouge&quot;&gt;PSea&lt;/code&gt;设计好了一个简单的POP网络请求库，再举一个简单的登录api使用例子：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;class LoginApi: PetRequest {

    var username : String = &quot;xxx&quot;
    var password : String = &quot;xxx&quot;
    var successHandler: SccuessCallBack?    
    var errorHandler: ErrorCallBack?
    var failureHandler: FailureCallBack?

    func needToken() -&amp;gt; Bool {
        return false
    }

    func petParameters() -&amp;gt; Parameters? {
        return [&quot;username&quot;:username,
                &quot;password&quot;:password]
    }
    
    func method() -&amp;gt; HTTPMethod {
        return .post
    }
    
    func requestURI() -&amp;gt; String {
        return &quot;/petday/login&quot;
    }
  
}

//使用例子
        LoginApi().request().success { (_, value) in
            
            }.failure { (_, _, _) in
                
                
            }.error { (_, _, _) in                
                
        }

然后又因为failure和error都已经经过业务层做处理了，不是特殊情况下，不需要额外做处理，又可以简写成
        LoginApi().request().success { (_, value) in
            
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;另外如果需要将成功的结果返回的时候转成对象，
首先在处理&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;func successParse(response: DataResponse&amp;lt;Any&amp;gt;) {
           guard let value = response.result.value as? [String:Any] else{
                return
        }
    //经过处理一系列结果
    //...
    //...
    let modelJSON =  //...需要转换成对象的合法JSON字典
        if let handler = self.successHandler {
            handler(modelJSON,value)
        }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后可以写成这样:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;ListApi().request().success(ListModel.self) { (model,value) in

}
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 09 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/09/%E7%94%A8Swift%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7POP%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/09/%E7%94%A8Swift%E6%89%93%E9%80%A0%E4%B8%80%E4%B8%AA%E8%BD%BB%E9%87%8F%E7%BA%A7POP%E7%9A%84%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E5%BA%93/</guid>
        
        <category>Swift-Tips</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>Swift高阶函数的使用</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;本文内容基于Swift 4&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;在读《Swift进阶》的时候发现,Swift提供了很多内置的高阶函数用于数组变形，使用高阶函数最大优势在于，用更少量的代码去解决问题。&lt;/p&gt;
&lt;h1 id=&quot;map&quot;&gt;map&lt;/h1&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let a = [1,2,3,4,5,6]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果要把这个数组中的元素每个都+1，按照以前的做法&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;var b = [Int]()
    for ele in a {
        b.append(ele+1)
    }
    print(b)//[2,3,4,5,6,7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但使用map之后&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let b = a.map { (ele) -&amp;gt; Int in
        return ele+1
    }
    print(b)//[2,3,4,5,6,7]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;同时也因为&lt;code class=&quot;highlighter-rouge&quot;&gt;Swift&lt;/code&gt;闭包的特性，上面的代码还可以写成&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let b = a.map{
        $0+1
    }
    print(b)//[2,3,4,5,6,7]
&lt;/code&gt;&lt;/pre&gt;
&lt;h1 id=&quot;flatmap&quot;&gt;flatMap&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;的用法很相像，通过对比两者的不难发现：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;public func map&amp;lt;T&amp;gt;(_ transform: (Element) throws -&amp;gt; T) rethrows -&amp;gt; [T]

public func flatMap(_ transform: (Element) throws -&amp;gt; String?) rethrows -&amp;gt; [String]
&lt;/code&gt;&lt;/pre&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;允许返回&lt;code class=&quot;highlighter-rouge&quot;&gt;nil&lt;/code&gt;值，对元素进行过滤再变形&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;flatMap&lt;/code&gt;可以将多维数组转成一维数组
    &lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let a = [[1,2,3],[4,5,6]]
 let b = a.flatMap {
     $0
 }
 print(b)//[1,2,3,4,5,6]
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;filter&quot;&gt;filter&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;用于过滤元素&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,5,6]
    //去掉a数组内&amp;lt;4的元素
    let b = a.filter { (value) -&amp;gt; Bool in
        return value &amp;gt; 4
    }
    print(b)
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;reduce&quot;&gt;reduce&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;reduce&lt;/code&gt;可以将数组中的元素合并到一个值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;let a = [1,2,3,4,5,6]
//如果要将a数组内所有元素相加，再+7，以前的写法是这样：
let count = 0
for value in a {
   count += value
}
count += 7
print(count)//28
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在使用reduce之后，事件就变得非常简单&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let b = a.reduce(7) { (count, value) -&amp;gt; Int in
        return count+value
    }
    print(b)//28
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;sequence&quot;&gt;sequence&lt;/h1&gt;
&lt;p&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;sequence&lt;/code&gt;可以生成无限的序列
假设我们要从遍历从0到100的偶数，以前的写法是：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    for i in 0..&amp;lt;26 {
        print(i*2) //0,2,4...48,50
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;而&lt;code class=&quot;highlighter-rouge&quot;&gt;sequence&lt;/code&gt;只需要:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    for i in sequence(first: 0, next: {$0+2}) {
        if i&amp;gt;50 {
            break
        }
        print(i) //0,2,4...48,50
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;sorted&quot;&gt;sorted&lt;/h1&gt;
&lt;p&gt;用于排序&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;//倒序
    let a = [1,2,3,4,5,6]
    let b =  a.sorted { (next, last) -&amp;gt; Bool in
        return next &amp;gt; last
    }
    print(b)//[6, 5, 4, 3, 2, 1]

    //根据字母顺序倒序
    let students: Set = [&quot;Kofi&quot;, &quot;Abena&quot;, &quot;Peter&quot;, &quot;Kweku&quot;, &quot;Akosua&quot;]
    let descendingStudents = students.sorted(by: &amp;gt;)
    print(descendingStudents)
    // Prints &quot;[&quot;Peter&quot;, &quot;Kweku&quot;, &quot;Kofi&quot;, &quot;Akosua&quot;, &quot;Abena&quot;]&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;split&quot;&gt;split&lt;/h1&gt;
&lt;p&gt;分割数组&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,5,6]
    //按照0分割数组，数组中没有0
    let b =  a.split(separator: 0)
    print(b[0])//[1, 2, 3, 4, 5, 6]
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,3,6]
    //按照3分割数组
    let b =  a.split(separator: 3)
    print(b)//[ArraySlice([1, 2]), ArraySlice([4]), ArraySlice([6])]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;prefix&quot;&gt;prefix&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;prefix&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;filter&lt;/code&gt;类似，过滤条件为true的时候会到结果中，区别在于，当为false的时候会直接结束&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,3,6]
    let b =  a.prefix(upTo: 4)
    print(b)//[1,2,3,4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&quot;drop&quot;&gt;drop&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;drop&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;prefix&lt;/code&gt;相反，当为true的时候元素会被丢弃，为false的时候会直接结束&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Swift&quot;&gt;    let a = [1,2,3,4,3,6]
    let b =  a.drop(while: { (value) -&amp;gt; Bool in
        if value &amp;lt; 3 {
            return true
        }
        return false
    })
     print(b)//[3, 4, 3, 6]
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/06/Swift%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/06/Swift%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%BF%E7%94%A8/</guid>
        
        <category>Swift-Tips</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>AVCaptureSession自定义相机获取的UIImage旋转无效</title>
        <description>&lt;p&gt;在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;AVCaptureSession&lt;/code&gt;自定义相机的时候，发现无论横竖拍出来，照片的方向总是不对，参考了下面的两个链接的方法依旧行不通，然后自己想了个办法去解决。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/39705993/is-uiimage-imagewithciimagescaleorientation-broken-on-ios10&quot;&gt;is-uiimage-imagewithciimagescaleorientation-broken-on-ios10&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/1315251/how-to-rotate-a-uiimage-90-degrees/30703714#30703714&quot;&gt;how-to-rotate-a-uiimage-90-degrees&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;通过使用重力加速计判断手机旋转的方向，再去设置&lt;code class=&quot;highlighter-rouge&quot;&gt;AVCaptureConnection&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;videoOrientation&lt;/code&gt;属性，代码如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;@interface FIDCameraHelper ()
@property (nonatomic,strong) CMMotionManager *motionManager;
@property (nonatomic,assign) UIImageOrientation orientation;
@end
@implementation FIDCameraHelper
- (CMMotionManager *)motionManager
{
    if (!_motionManager)
    {
        _motionManager = [[CMMotionManager alloc]init];
    }
    return _motionManager;
}

//启动重力加速计
+ (void)startUpdateAccelerometerResult:(void (^)(UIImageOrientation orientation))result
{   
    if ([sharedManager.motionManager isAccelerometerAvailable] 
        [sharedManager.motionManager setAccelerometerUpdateInterval:0.1];
        [sharedManager.motionManager startAccelerometerUpdatesToQueue:[NSOperationQueue currentQueue] withHandler:^(CMAccelerometerData *accelerometerData, NSError *error)
         {
             double x = accelerometerData.acceleration.x;
             double y = accelerometerData.acceleration.y;
             if (fabs(y) &amp;gt;= fabs(x))
             {
                 if (y &amp;gt;= 0){
                     //Down
                     if (result) {
                         result(UIImageOrientationDown);
                     }
                 }
                 else{
                     //Portrait
                     if (result) {
                         result(UIImageOrientationUp);
                     }
                 }
             }
             else
             {
                 if (x &amp;gt;= 0){
                     //Right
                     if (result) {
                         result(UIImageOrientationRight);
                     }
                 }
                 else{
                     //Left
                     if (result) {
                         result(UIImageOrientationLeft);
                     }
                 }
             }
         }];
    }
}

- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputSampleBuffer:(CMSampleBufferRef)sampleBuffer fromConnection:(AVCaptureConnection *)connection
{
    
    CVPixelBufferRef pixelBuffer = CMSampleBufferGetImageBuffer(sampleBuffer);
    CFDictionaryRef attachments = CMCopyDictionaryOfAttachments(kCFAllocatorDefault, sampleBuffer, kCMAttachmentMode_ShouldNotPropagate);
    CIImage *ciImage = [[CIImage alloc] initWithCVPixelBuffer:pixelBuffer options:(NSDictionary *)CFBridgingRelease(attachments)];
    //根据方向设置videoOrientation
    switch (self.orientation) {
        case UIImageOrientationUp:
        {
            connection.videoOrientation = AVCaptureVideoOrientationPortrait;
            break;
        }
        case UIImageOrientationDown:
        {
            connection.videoOrientation = AVCaptureVideoOrientationPortraitUpsideDown;
            break;
        }
        case UIImageOrientationLeft:
        {
            connection.videoOrientation = AVCaptureVideoOrientationLandscapeRight;
            break;
        }
        case UIImageOrientationRight:
        {
            connection.videoOrientation = AVCaptureVideoOrientationLandscapeLeft;
            break;
        }
        default:
            break;
    }
    self.cameraImage = [UIImage imageWithCIImage:ciImage scale:1.0 orientation:self.orientation];
}

@end
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 06 Mar 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/03/06/AVCaptureSession%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA%E8%8E%B7%E5%8F%96%E7%9A%84UIImage%E6%97%8B%E8%BD%AC%E6%97%A0%E6%95%88/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/03/06/AVCaptureSession%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9B%B8%E6%9C%BA%E8%8E%B7%E5%8F%96%E7%9A%84UIImage%E6%97%8B%E8%BD%AC%E6%97%A0%E6%95%88/</guid>
        
        <category>iOS</category>
        
        <category>问题随笔</category>
        
        
      </item>
    
      <item>
        <title>Swift-Tips String截取字符串</title>
        <description>&lt;p&gt;
在&lt;code class=&quot;highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt;中我们可以使调&lt;code class=&quot;highlighter-rouge&quot;&gt;substringWithRange&lt;/code&gt;的方法达到截取字符串的效果&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[@&quot;123&quot; substringWithRange:NSMakeRange(1, 2)];
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在Swift 4之前，也是有类似的方法&lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;ss&quot;.substring(with: &amp;lt;Range&amp;lt;String.Index&amp;gt;&amp;gt;)&lt;/code&gt;  ,但是在Swift 4之后被弃用了，我们可以通过用&lt;code class=&quot;highlighter-rouge&quot;&gt;extension&lt;/code&gt;的方法去给他增加截取字符串的方法&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension String{
    func to(_ index:Int) -&amp;gt; String? {
        let toIndex = String.Index.init(encodedOffset: index)
        guard toIndex &amp;lt; self.endIndex else { return nil }
        return String(self[...toIndex])
        
    }
    func from(_ index:Int) -&amp;gt; String? {
        let fromIndex = String.Index.init(encodedOffset: index)
        guard fromIndex &amp;lt; self.endIndex else { return nil }
        return String(self[fromIndex..&amp;lt;self.endIndex])
    }
    func subString(_ from:Int,to:Int) -&amp;gt; String? {
        let toIndex = String.Index.init(encodedOffset: from)
        let fromIndex = String.Index.init(encodedOffset: to)
        guard toIndex &amp;lt; self.endIndex,
            fromIndex &amp;lt; self.endIndex,
            toIndex &amp;lt;= fromIndex else { return nil }
        return String(self[toIndex...fromIndex])
    }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;现在又可以方便的截取字符串了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(&quot;12345678&quot;.to(3)) //Optional(&quot;1234&quot;)  

print(&quot;12345678&quot;.from(3)) //Optional(&quot;45678&quot;)  

print(&quot;12345678&quot;.subString(3, to: 5))  //Optional(&quot;456&quot;)  
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;另外我们还可以结合Swift下标的特性，达到通过取字符串下标截取字符串&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;extension String{
    subscript(index:Int) -&amp;gt; String? {
        return subString(index, to: index)
    }
    subscript (bounds: CountableClosedRange&amp;lt;Int&amp;gt;) -&amp;gt; String? {
        return subString( bounds.lowerBound, to: bounds.upperBound)
    }
    subscript (bounds: CountableRange&amp;lt;Int&amp;gt;) -&amp;gt; String? {
        return subString( bounds.lowerBound, to: bounds.upperBound)
    }   
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;print(&quot;12345678&quot;[2])  //Optional(&quot;3&quot;)  

print(&quot;12345678&quot;[3...5])  //Optional(&quot;456&quot;)

print(&quot;12345678&quot;[100])  //nil
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Mon, 29 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/29/Swift-Tips-String%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/29/Swift-Tips-String%E6%88%AA%E5%8F%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid>
        
        <category>Swift-Tips</category>
        
        <category>Swift</category>
        
        
      </item>
    
      <item>
        <title>浅谈iOS在物联网应用中的架构</title>
        <description>&lt;p&gt;这篇文章在很早之前就在酝酿，我目前的开发生涯中，在现在这间公司之前，都是和硬件打交道的，期间踩了很多坑，尝试了很多不同方式的写法和架构的改变，因此有了些经验，可能文中的一些点大家都比较熟悉，只是在处理上略有不同，接下来我会分享一下自己的做法，作为对自己在iOS物联网方面一个短暂的总结吧。如果有什么不同的意见，也可以在评论区留下评论，可以一起探讨一下问题。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;物联网在ios上的表现无非两种&quot;&gt;物联网在iOS上的表现，无非两种&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;WiFi&lt;/li&gt;
  &lt;li&gt;蓝牙&lt;br /&gt;
而这两种表现形式，在做的事情无非就是：&lt;br /&gt;
&lt;img src=&quot;http://foolishtalk.oss-cn-shenzhen.aliyuncs.com/2345604-7134da016a716ebf.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://foolishtalk.oss-cn-shenzhen.aliyuncs.com/0C1F4A7B-90A5-4CB1-B51A-A06A48116480.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;硬件和App之间如何通讯实现交互不属于本文讨论的范畴，因为其表现形式都会像上图一样。从代码层上来讲，通讯这部分都应该封装成一个类，外部无需知道内容是如何实现，业务方只需要得到设备返回的数据以及将数据发送给设备就可以了，类似于下面这样:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@protocol&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeviceDataManagerDelegate&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSObject&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;//  这里的device他可以是蓝牙的外设，也可以是能某种能标示设备的tag，能get到点就可以了
&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;readData&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;@interface&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DeviceDataManager&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NSObject&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;sendData&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;device&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;为了下面的内容更好理解，避免和http请求的网络层混淆，我把这一层叫作&lt;code class=&quot;highlighter-rouge&quot;&gt;传输层&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在&lt;code class=&quot;highlighter-rouge&quot;&gt;网络层&lt;/code&gt;中，我们一般会根据业务对网络请求进行封装，避免重复写处理非正常结果时的代码，传输层中并不能像网络层一样能直接使用得到的数据，传输层中得到一般都是经过自定的协议包装加密过后的数据，而不像网络层使用JSON那么方便，抛开自定义的协议来讲，物联网中传输层最基本的内容都会由以下的组成：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;传输层数据
│
├────命令字(功能)
├────消息体(行为)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在得到这部分数据之后，我们会经过根据事先与硬件方约定好的协议去进行解析，例如&lt;code class=&quot;highlighter-rouge&quot;&gt;0x0100&lt;/code&gt;这个数据代表了什么：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;           开关（功能）  状态（行为）
传输层数据    0x01         0x00 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这部分数据看起来十分简单，但是对于一个完全没有看过事先与硬件方约定好的协议来说，是非常难懂的。&lt;br /&gt;
在我当时团队的code review的时候，也发现了因此带来的一些问题：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;1.随着版本更新，新的协议增加导致数据变得越来越庞大，接手的同学一脸懵逼;
2.处理数据后，通知满天飞，甚至没有处理消息体直接丢;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;del&gt;对于第一个问题，我曾经有考虑过使用一门语言作出通用的解析库，硬件端、移动端、前端、后台如果需要解析这个数据，只需要传入传输层数据，返回的就是JSON对象这样的一个方案。想象中挺美好的，但是这样也会带来解析库的维护成本以及额外的文档，后来还是放弃了这个做法。&lt;/del&gt;&lt;br /&gt;
 在第一的问题上，最终还是老老实实的手动解析成model。&lt;br /&gt;
 造成第二个问题，很大程度也是因为团队里没有约定很好的代码规范导致的。在当时，我还没有很深入的了解过AOP，选择的是在一开始处理完数据之后，会用另外一个model的block去接收，然后另外在controller去订阅，这种做法有个弊端就是代码量十分多，后来我了解到了&lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;之后，我强烈推荐使用&lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;去解决这个问题，这里用AOP好处是：&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;不需要再管理通知的监听和移除,也因此避免了通知带来的没有释放控制器的问题;&lt;/li&gt;
  &lt;li&gt;通过&lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;，代码会变得更加整洁和少;&lt;br /&gt;
空说无益，还是直接上图吧&lt;br /&gt;
&lt;img src=&quot;http://foolishtalk.oss-cn-shenzhen.aliyuncs.com/D45F4AE5-5D7F-4C98-9AB9-B26886FFC8FF.png&quot; alt=&quot;&quot; /&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AOP&lt;/code&gt;的框架，我看了网上也有很多，大部分是在&lt;a href=&quot;https://github.com/steipete/Aspects&quot;&gt;Aspects&lt;/a&gt;的基础上封装的，更推荐直接去使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Aspects&lt;/code&gt;,像是一些发送队列，几秒内只接收一个，几秒内只处理最后一个这种需求，都比较方便，当然也用&lt;code class=&quot;highlighter-rouge&quot;&gt;RAC&lt;/code&gt;或者&lt;code class=&quot;highlighter-rouge&quot;&gt;RxSwift&lt;/code&gt;处理，见仁见智。&lt;/p&gt;

&lt;p&gt;怕讲的太抽象，放一段使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Aspects&lt;/code&gt;的伪代码：&lt;/p&gt;

&lt;p&gt;Action的伪实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 

&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TAction&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;data&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;//处理数据
&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;@&quot;hello action&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Store的伪代码实现&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;TStore&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;handler_block&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;object_getClass&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;([&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TAction&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;])&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;aspect_hookSelector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;@selector&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;parse&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:)&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;withOptions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AspectPositionAfter&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;usingBlock&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AspectInfo&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;aspectInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSData&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;aspectInfo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;originalInvocation&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;getReturnValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;handler_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;handler_block&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;error&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Controller上，我们就只需要订阅Store的消息就可以了：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;@implementation&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ViewController&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;viewDidLoad&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;super&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;viewDidLoad&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];&lt;/span&gt;    
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;TStore&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;subscribe&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;^&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;NSString&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;NSLog&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;@&quot;%@&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;str&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}];&lt;/span&gt;    
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;@end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;p&gt;物联网除了还会有很多关于网络层的小坑以外，别的就和其他领域的也差不多了，所以也不想说太多老生常谈的东西，就这样。&lt;/p&gt;
</description>
        <pubDate>Tue, 16 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/16/%E6%B5%85%E8%B0%88iOS%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E6%9E%B6%E6%9E%84/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/16/%E6%B5%85%E8%B0%88iOS%E5%9C%A8%E7%89%A9%E8%81%94%E7%BD%91%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E6%9E%B6%E6%9E%84/</guid>
        
        <category>架构</category>
        
        <category>物联网</category>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>在UITableView中使用RunLoop遇到的坑</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;在做Pet Day的时候，遇到一个这样的需求，假定&lt;code class=&quot;highlighter-rouge&quot;&gt;tableView&lt;/code&gt;中的section初始值为50,在往上或者往下的时候，需要通过计算得知更多的&lt;code class=&quot;highlighter-rouge&quot;&gt;dataSource&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;然后我一开始的做法，是在&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;的方法在接近顶部或者接近底部的时候，进行计算&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    func tableView(_ tableView: UITableView,
                   willDisplay cell: UITableViewCell,
                   forRowAt indexPath: IndexPath) {
        //如果大于数据源总数-30，需要开始计算后面的内容
        if indexPath.section &amp;gt; dataSource.count - 30 {
           
        }else if indexPath.section &amp;lt; 30 {//如果小于30，需要开始计算前面的内容
           
    }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;strong&gt;但是，这样做会有问题&lt;/strong&gt;，在遇到向上刷新的时候，会多次调用&lt;code class=&quot;highlighter-rouge&quot;&gt;- (void)tableView:(UITableView *)tableView willDisplayCell:(UITableViewCell *)cell forRowAtIndexPath:(NSIndexPath *)indexPath;&lt;/code&gt;的方法，导致数据突然增多。&lt;/p&gt;

&lt;p&gt;后来用定时器实现触发后0.5秒内拦截，代码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   guard share.operations.contains(tag) == false else {
            return
        }
        let timer = Timer.bs_scheduledTimer(withTimeInterval: interval, block: { (timer) in
            weak var weakTimer = timer

            weakTimer?.invalidate()
            weakTimer = nil
        }, repeats: false)
        share.operations.insert(tag)
        timer.fire()
        shareRunLoop().add(timer, forMode: .defaultRunLoopMode)

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;这时候runloop的坑就来了&quot;&gt;&lt;strong&gt;这时候RunLoop的坑就来了&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;第一次触发…正常&lt;br /&gt;
第二次触发…0.5秒过了，好几秒过去了，还是没有反应&lt;br /&gt;
…&lt;br /&gt;
终于在停止刷新后，再往上刷，正常了&lt;/p&gt;

&lt;p&gt;我自己的推测是因为tableView在刷新的过程中，tableView的刷新事件比定时器的事件先进，需要等刷新停止了，定时器才能执行&lt;br /&gt;
然后换了另外一种实现方式就没问题了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;        
        guard share.operations.contains(tag) == false else {
            return
        }
            operation()
        
        DispatchQueue.main.asyncAfter(deadline: DispatchTime.now() + interval, execute: {
            share.operations.remove(tag)
        })
        
        share.operations.insert(tag)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Fri, 12 Jan 2018 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2018/01/12/%E5%9C%A8UITableView%E4%B8%AD%E4%BD%BF%E7%94%A8RunLoop%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</link>
        <guid isPermaLink="true">http://localhost:4000/2018/01/12/%E5%9C%A8UITableView%E4%B8%AD%E4%BD%BF%E7%94%A8RunLoop%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/</guid>
        
        <category>问题随笔</category>
        
        <category>RunLoop</category>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>swift使用protocol的时候出现循环引用</title>
        <description>&lt;p&gt;在给Alamofire用protocol封装一层业务的时候，定义了以下的协议和方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol BaseRequest {
}
extension FIDRequest {
    func complete(_ completionHandler: @escaping ((DataResponse&amp;lt;Any&amp;gt;) -&amp;gt; ())) {
        let url = baseURL()+requestURI()
            Alamofire.request(url, method: method(), parameters: parameters(), encoding: encoding(), headers: headers()).responseJSON(completionHandler: completionHandler)
    }
}

protocol Request {

}

extension Request {
    func request() -&amp;gt; WBBaseRequest {
            complete {  (response)  in
//这里还有段代码造成循环引用
            }
       }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时候问题就来了，正常情况下，应该使用&lt;code class=&quot;highlighter-rouge&quot;&gt;[weak self]&lt;/code&gt;就可以解决了，但是在使用&lt;code class=&quot;highlighter-rouge&quot;&gt;protocol&lt;/code&gt;的时候，是无法使用&lt;code class=&quot;highlighter-rouge&quot;&gt;[weak self]&lt;/code&gt;的，然后就会有以下的报错
&lt;code class=&quot;highlighter-rouge&quot;&gt;'weak' may only be applied to class and class-bound protocol types, not 'Self'&lt;/code&gt;&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    func request() -&amp;gt; WBBaseRequest {
            complete {  (response) [weak self]  in //这个地方会报错 'weak' may only be applied to class and class-bound protocol types, not 'Self'
//这里还有段代码造成循环引用
            }
       }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;直接解决这个问题的方式是，将 &lt;code class=&quot;highlighter-rouge&quot;&gt;BaseRequest&lt;/code&gt;声明为只有类才可以使用&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol BaseRequest : class {
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后就可以愉快的使用&lt;code class=&quot;highlighter-rouge&quot;&gt;[weak self]&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;总结：
&lt;code class=&quot;highlighter-rouge&quot;&gt;weak&lt;/code&gt;只能用在类或者类的协议中，如果在协议扩展中使用了类而造成了循环引用，协议就需要指定必须是&lt;code class=&quot;highlighter-rouge&quot;&gt;class&lt;/code&gt;才可以使用，&lt;code class=&quot;highlighter-rouge&quot;&gt;struct&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;enum&lt;/code&gt;是不会造成循环引用的
参考链接： 
&lt;a href=&quot;https://stackoverflow.com/questions/38841127/why-can-the-keyword-weak-only-be-applied-to-class-and-class-bound-protocol-typ&quot;&gt;Why can the keyword “weak” only be applied to class and class-bound protocol types&lt;/a&gt;
 &lt;a href=&quot;https://stackoverflow.com/questions/24066304/how-can-i-make-a-weak-protocol-reference-in-pure-swift-w-o-objc&quot;&gt;How can I make a weak protocol reference in ‘pure’ Swift (w/o @objc)&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Thu, 07 Dec 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/12/07/swift%E4%BD%BF%E7%94%A8protocol%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/12/07/swift%E4%BD%BF%E7%94%A8protocol%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B0%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</guid>
        
        <category>Swift</category>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>自己动手做Swift-Package-Manager</title>
        <description>&lt;p&gt;Swift Package Manager是苹果自家的包管理工具，他和iOS开发中的Cocoapod或者Carthage类似，但是我们可以从他&lt;a href=&quot;https://github.com/apple/swift-package-manager&quot;&gt;GitHub&lt;/a&gt;文档看到&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Note that at this time the Package Manager has no support for iOS, watchOS, or tvOS platforms.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;就是SPM是不支持  iOS, watchOS, or tvOS 平台，不过如果你想在不是mac OS的系统下使用swift，那就能用到SPM了。&lt;/p&gt;

&lt;p&gt;建立一个以下的目录&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;example[这是个文件夹，起什么名字都行]
├── Sources[这是个文件夹，默认这个名字，里面放你需要生成库的.swift文件]
│   ├── Person.swift
│   ├── Cat.swift
│   └── Dog.swift
└── Package.swift[必须这个名字]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;然后在Package.swift中写上依赖的内容&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import PackageDescription

let package = Package(
    name: &quot;exmaple&quot; // 这里填你这个Package的名字
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;然后去github生成一个远程仓库，在example目录下&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git init
$ git add *
$ git commit -m &quot;SPM example&quot;
$ git remote add origin git@github.com:xxx/example.git
$ git push -u origin master
$ git tag 1.0.0
$ git push --tags
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时候就可以新建一个目录测试是否成功了&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ mkdir test
$ cd test
$ vim Package.swift
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在Package.swift中输入&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import PackageDescription

let package = Package(
    name: &quot;test&quot;,
    targets: [],
    dependencies: [
        .Package(url: &quot;https://github.com/xxx/example.git&quot;, 
majorVersion: 1)
        ]
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在 test 目录下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ swift build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这时候应该看到提示成功了，到这里已经完成了&lt;/p&gt;

&lt;h2 id=&quot;附带一些自己踩过的坑&quot;&gt;附带一些自己踩过的坑&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;如果example的目录下有很多别的文件夹，在&lt;code class=&quot;highlighter-rouge&quot;&gt;$ swift build&lt;/code&gt;的时候有可能会出现这个错误
&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;k&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;has&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;unsupported&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;layout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;multiple&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;source&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;roots&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;found&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;example
├── Sources
│   ├── Person.swift
│   ├── Cat.swift
│   └── Dog.swift
└── Package.swift
│── a[不需要参与编译的文件]
│── b[不需要参与编译的文件]
└── Package.swift
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;出现这个错误的时候example/Package.swift 需要这样写：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import PackageDescription

let package = Package(
    name: &quot;exmaple&quot;, // 这里填你这个Package的名字
    exclude:[&quot;a&quot;,&quot;b&quot;]
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果你这个库还依赖了别的库，还可以这样写：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import PackageDescription

let package = Package(
    name: &quot;exmaple&quot;, // 这里填你这个Package的名字
	dependencies: [
		.Package(url: &quot;https://github.com/depend/depend.git&quot;, majorVersion: 0)
	],
    exclude:[&quot;a&quot;,&quot;b&quot;]
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ol&gt;
  &lt;li&gt;majorVersion只能是Int，我如果发布的不是整数tag怎么办？
可以换成选择版本范围，默认是根据当前范围最高的版本更新的
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import PackageDescription
let package = Package(
 name: &quot;test&quot;, 
 dependencies: [
          .Package(url: &quot;https://github.com/xxx/example.git&quot;,versions: Version(0, 0, 0)..&amp;lt;Version(1, .max, .max))]
 ]
)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;swift build了很久最后出现 error: reachedTimeLimit
这种情况我之前遇到过，具体是为什么导致当时没留意，但是你可以从这几个方面排查：
    &lt;ol&gt;
      &lt;li&gt;Package指定的版本是否有错&lt;/li&gt;
      &lt;li&gt;更新了新的版本，不能直接&lt;code class=&quot;highlighter-rouge&quot;&gt;$ swift build&lt;/code&gt;需要：
        &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ rm -rf .build/
$ rm Package.resolved
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;        &lt;/div&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;dependencies是否有错&lt;/li&gt;
  &lt;li&gt;如果有引入c文件还需要特殊处理，因为我还没试过，只是在看文档的时候发现有，如果工程中有使用可以去&lt;a href=&quot;https://swift.org/package-manager/&quot;&gt;Swift.org&lt;/a&gt;和&lt;a href=&quot;https://github.com/apple/swift-package-manager&quot;&gt;GitHub&lt;/a&gt;了解更多&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Sun, 22 Oct 2017 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/2017/10/22/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9ASwift-Package-Manager/</link>
        <guid isPermaLink="true">http://localhost:4000/2017/10/22/%E8%87%AA%E5%B7%B1%E5%8A%A8%E6%89%8B%E5%81%9ASwift-Package-Manager/</guid>
        
        <category>Swift</category>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
